나머지 (%)를 어디에 쓸까?
홀수 : X % 2 = 1
짝수 : X % 2 = 0

어떤 값이 들어와도 5를 넘기면 안돼
X % 5 = 0 ~ 4 사이의 값만 반환
---------------------------
거든 제곱

const num = 2**3
consoele.log(num)
----------------------------
연산자 줄여서 쓰기

let num = 10
(num = num + 5) == (num += 5)
x= , -= , %=
-----------------------------
증가 연산자 num++
감소 연산자 num-- 

let num = 10
let result = num++    ==    (10)
let result = ++num    ==    (11)
---------------------------------
비교 연산자
a = 3 (a에 3을 넣어준다)
a == 3 (a와 3이 같은가?) // 동등 연산자
  a = 1, b = "1"  | a == b (true) 
a != 3 (a와 3이 다른가?)

일치 연산자
a = 1, b = "1"
a === b (fasle) 타입까지 비교함 
---------------------
논리 연산자

 || (or) 여러 갸중 하나라도 true 면 true. 즉 모든 값이 fasle 일때 만 fasle를 반환
 ex) a || b

  const name = '건호';
  const age = 30;

  if (name === 'make' || age > 19) {
    console.log('통과');
  } else {
    console.log('돌아가')
  }
/////////////
// && (and) 모든 값이 true 면 true. 즉 하나라도 fasle 면 fasle 를 반환
 ex) a && b

  const name = '건호'
  const age = 3

  if (name === '예현' && age > 19) {
    console.log('통과')
   } else {
   console.log('실패')
   }
////////////////////
//  ! (not) true 면 fasle. fasle 면 true
 ex) !a

 const age = prompt('몇살이니?')
 const isAult = age > 19

 if( !isAult ) {
    console.log('돌아가!!')
    }
////////////////////
// 우선순위 
 and 연산자가 or 보다 우선 계산 된다

 const gender = 'm'
 const name = 'jane'
 const isAdult = true

 if (gender === 'm' && (name === 'mike' || isAdult)) {
   console.log('통과')
 } else {
   console.log('돌아가')
 } 
-------------------------------
반복문
////////////////////////
//for
for(let i = 0; i < 10; i++){
  // 초기값 ; 조건(false가 되면 멈춤); 코드 실행 후 작업
// 반복 코드
}
///////////////////////////////
//while

while
let i = 0
while (i <10) {
  // 코드 
  i++
}

 while(true){
 let answer = confirm('계속할까요?')
 if(!answer) {
   break
  
 }}
/////////////////////////
// do... while

코드를 1번 실행하고 조건을 확인함

let i = 0 
do {
  // 코드
  i++
}while(i<10)

break: 멈추고 빠져 나옴
continue: 멈추고 다음 반복으로 진행

* while(true){} 는 무한 반복 됨
* 명확한 횟수가 정해져 있으면 for 문을 사용하고 그게 아니면 while 을 사용
------------------------------
 continue
 짝수만
 for(let i = 0; i < 10; i ++) {
   // 짝수가 나오면 값이 0이니까 false여서if문을 빠져 나오고
   // 홀수가 나오면 값이 1이니까 true여서 if문을 실행한다
   if(i%2){
     continue
   }
   console.log(i)
 }
----------------------------------
//switch 문

switch(평가) {
  case A :
  // A 일 때 코드
  case B :
  // B 일 때 코드
  .....
}

* case A 가 true 면 break 를 만나기 전까지 모든 case를 실행합니다. 
  (각 케이스에 break 를 하는게 좋음)
* 각 case 에 해당 하는게 없을 경우를 위해 default 를 작성해야합니다.

let fruit = prompt('무슨 과일을 사고 싶나요?');

switch(fruit){
  case'사과':
    console.log('100원입니다.');
    break;
  case'바나나':
    console.log('200원입니다.');
    break;
  case'키위':
    console.log('300원입니다.');
    break;
  case'메론':
  case'수박':
    console.log('500원입니다.');
    break;
   default:
    console.log('그런 과일은 없습니다.');
}
-----------------------------------------------
// 함수(function)

함수↓↓  함수명↓↓     ↓↓매개변수
function sayHello(name){
  console.log(`Hello,${name}`)
}
함수 호출↓↓      ↓↓매개변수
      sayHello('건호')

//////////////////////
//매개변수가 없는 함수

function showError(){
alert('에러가 발생했습니다. 다시 시도해주세요.')
}
showError();

//////////////////////
//매개변수가 있는 함수

function sayHello(name){
  const msg = `hello, ${name}`
}
console.log(msg)
sayHello('건호')
sayHello('예현')
sayHello('삐삐')

//////////////////////////
function sayhello(name){
  let msg = `hello`
  if(name){
    msg += ` ${name}`
  }
  console.log(msg)
}
sayhello()
sayhello('건호')
console.log(msg) // 함수 내부의 변수를 함수 밖에서 사용할 수 없다

///////////////////////
// 전역 변수와 지역 변수

let msg = "환영합니다" // 전역 변수
console.log(msg)
function sayHello(name) {
  let msg = "안녕"  // 지역 변수
  console.log(msg + ' ' + name)
}

sayHello('건호')
console.log(msg)

//////////////

let name = "예현"
function sayhello(name){
  console.log(name)
}
sayhello()
sayhello('삐삐')

* 매개변수로 받은 값은 복사된 후 함수의 지역변수가 됩니다. 
  전체 서비스에서 공통으로 바라봐야하는 변수를 제외하고는 
  지역 변수로 쓰는 습관을 드리는게 좋음 
//////////////////////
// or

function sayHello(name){
//               ↓↓매개변수가 없어 false  
//                       ↓↓매개변수가 없으면 나옴  
// or 은 마지막 true를 반환한다
  let newName = name || '친구'
  let msg = `안녕, ${newName}`
  console.log(msg)
}
sayHello()
sayHello('푸푸')

//////////////////////////
// dafault value (기본값)

//                  기본값 ↓↓
function sayHello(name = '친구'){
  let msg = `안녕, ${name}`
  console.log(msg)
}
sayHello()
sayHello('푸푸')
* 매개변수가 없을때 dafault value 할당됨

//////////////////////////
// return 으로 값 반환

function add(num1, num2) {
  return num1 + num2
}
const result = add(2, 3)
console.log(result) // return 된 값을 확인하기 위해서 작성했음

* return 문이 없는 함수는 항상 undefind 를 반환한다

///////////////
function showError(){
  alert('에러가 발생했습니다.')
  return
  alert('이 코드는 절대 실행되지 않습니다.')
}
const result = showError()
console.log(result) 

* return 문이 있으면 그 즉시 오른쪽의 값을 실행하고 반환한 후 종료함 
  그래서 함수를 종료하는 목적으로 사용하기도 함
* return 만 있고 값이 없어도 undefind 를 반환한다

--------------------------------------------------
// 함수 표현식 화살표 함수


//함수 선운문 vs 함수 표현식 // 그래서 뭐가 더 좋은냐? 함수 선언문을 주로 써라!
//함수 표현식 : 코드에 도달하면 생성
let sayHello = function(){
  console.log('함수 표현식이야')
}
/////////////

* 함수 선언문 : 어디서든 호출 가능
sayHello()
function sayHello(){
  console.log("함수 선언문 이라서 위에서 호출해도 찍혀")
}

* 자바스크립트는 실행 전 초기화 단계에서 초기에 모든 함수 선언문을 찾아서
  생성해 둡니다. 즉 눈으로 봤을 때와 다르게 선언문들은 다 코드의 위로
  올라가 코드를 리딩합니다. 이를 ~~hoisting(호이스팅)~~ 이라고 합니다.
  오해할 수 있는데 코드 위치가 실제로 올라간다는 것은 아님!

///////////////////
// 화살표 함수(arrow function)

let add = function(num1, num2){
  return num1 + num2
}
 ↓↓↓↓↓ 화살표 함수로 변경

let add = (num1, num2) => {
    return num1 + num2
}
 ↓↓↓↓↓ 코드가 한줄이고 return 이 있기 때문에

let add = (num1, num2) => (
     num1 + num2
)

 ↓↓↓↓↓ return 문이 한줄이라면 

let add = (num1, num2) => num1 + num2

 ↓↓↓↓↓ 인수가 하나라면 

let add = num1 => num1 + num2

* 인수가 없는 함수면 괄호()를 생략할 수 없습니다.
* return 문이 있다고 해도 return 전에 여러가지 코드가 있으면 
  대괄호 {} 를 일반관호 () 로 사용할 수 없습니다.

///////////////

const add = function (num1 + num2) {
  const result = num1 + num2
  return result
}
 ↓↓↓↓↓ 화살표 함수로 변경

const add = (num1, num2) => (
  num1 + num2
)

---------------------------------------
//객체(object)